# 関数型プログラミングの基礎を学ぶよ

## 関数とデータは同じ

lambdaを使えば関数型ってわけではない。どこにでも、なんにでも関数が適用できる（ここからHOP、高階関数の概念が出てくる）のが関数型。

OOPとFPでは、出くわす問題は同じだが解決の方法が違う。
たとえばOOPの世界でオブジェクトとクラスに分かれている役割も、関数型の世界ではすべて関数。
汎化や共通化のためにも、継承などの特別な概念ではなく単なる関数を使う。

## カリー化と部分適用

関数を出力できることを活かして、複数のパラメータを持つ関数を分解して単一の引数を取るようにすることを「カリー化」と呼ぶ。
F#では、複数のパラメータを持つ関数はすべてカリー化された形で定義できる。

```
'a->'b->'c
```

上記は、 `'a` 型の引数を1つ取って関数を返すカリー化された関数にも見えるし、 `'a` と `'b` を受け取って `'c` を返す関数にも見える。

これを利用すると、関数の部分適用によって振る舞いを制限したり柔軟にしたりできる。

## 全域関数（Total functions）

例外によって型定義が嘘をつくことを許容してしまうことがある（ゼロ除算など）。
これを避けるためには、

- 入口を狭める（inputの型定義を制限する）
- 出口を広げる（出力にoption型を利用する）

## 関数合成

関数合成を使うことで、ユーザーが中間成果物に対して完全に無知でいられるようになる。
F#では `|>` （パイプ）を使うことで実現できる。UNIXのパイプの仕組みと似ている。
これをあらゆるレイヤーの関数で繰り返すことで、デカいアプリケーションを構築していける。

## 型パズル問題

Option型かどうか、非同期処理かどうかなど、型パズル問題は正直出る。
とはいえこれも、型をマッチさせる小さな関数を利用すれば解決できる。

# 感想

何もかも関数、はまじで分かる。というか、分かる体になった（なってしまった）。
出くわす問題が同じだが解決方法がすべて関数、というのは、とてもしっくり来る説明。

カリー化のメリットがわからない...。単にそういうテクニック？

関数合成の例文が、どことなくClojure味を感じる。