Bounded Contextをまたぐ業務フローを、ひとつのワークフローで実装してしまっている場面が多々ある。
データモデルとはまた別だろうけど、ドメインモデルとして分ける必要性はなんとなく理解しつつある。

あらためてドメイン設計を見返すと、「未検証の依頼書」など、状態に対してとても敏感に取り扱っている印象を受けた。
これが全部型に変換されていくのか...。なるほど...？
関数型（関数のインターフェースを決める型？）は、ワークフローを定義する時に使うのか！伏線回収感。

代表的なドメインモデルのパターンには下記がある。
- 単なる値
- AND型
- OR型
- ワークフロー

未知のドメインモデルは、それを示すための「Undefined」型を独自に作って、 `exn` という例外を吐くようにしておけば、型を利用したまま設計を進められる。
そして利用時に適宜実装を置き換えていける。

永続化された識別子を持っているデータをEntity、そうでないデータをValue Objectという。
F#では「Structural Equality」がサポートされているので、直積型でも直和型でもいい感じに同一性を検査してくれる。

EntityのIDを直和型に足すには、各選択肢の型にIDを足すのが、冗長だが実践的で良い。
利用（=パターンマッチ）時にかんたんに全フィールドにアクセスできるため。

Entityは「Structural Equality」に従ってほしくない。よってF#では `Equals` と `GetHashCode` をoverrideすることで、「Structural Equality」の適用を避けることができる。
が、関数の振る舞いが変わるのは手間なので `NoEquality` アノテーションをつけることで同一性の検査を拒否し、IDプロパティを直接比較するよう強制するのが、明示的で良い。

DDDではAggregate(集合)の概念を用いて、子Entityが更新されたらAggregate Root(集合の根)も更新することになる。たとえばOrderLineが1行書き換わったら、Order全体を再生成する必要がある。
これを徹底することで、一貫性と不変性を強化することができる。
Aggregateを管理するために、単に参照さえ取れればいい（例: Orderに、発注者のCustomerを埋め込みたい）場合は、Idの型だけを埋め込むのが良い。なぜなら、顧客情報を変更した時にすべての発注に埋め込まれた顧客情報も更新しなければいけないのは、本来やりたかったことではないから。
これを整理すると、OrderとOrderLineは依存関係にあるが、OrderとCustomerは互いに独立したAggregateだといえる。

Aggregateは永続化の単位としても重要。ひとつのAggregateは読み込みも保存もいっぺんに行う必要がある。

次章、Constrained Typeや、状態の違うOrderの取り扱いについて見ていくよ。

## 感想・疑問
シンプルなデータ型の代替えって、ほんとか？
`OrderId of int` って、ほぼ100%嘘やん。
と思ったけど、ちゃんと「Constrained Value」という形で次チャプターで話題に上がるらしい。

OOPと異なり、FPではデータと振る舞いを分離する。でもそれだけでは、どのデータとどの関数が組み合わせ可能なのか分からない。
そこでF#では厳格な型定義を、その橋渡しに使っているんだな...？
動的型付けのClojureで、データと振る舞いの組み合わせはどう管理していくのがいいんだろう。
