この章では、Integrity（正しさ）とConsistency（一貫性）について話す。
たとえば下記のようなことを、どうやって取り扱うかを議論していく。

- `UnitQuantity` は1~1000の間にいなければいけない
- `Order` は少なくとも1つの `OrderLine` を持っていなければいけない
- `Order` を発送部に渡す前には、必ず正しい発送先住所を含んでいる必要がある
- `Order` の総額と、 `OrderLine` の内容は一致しなければいけない
- `Order` が確定したら、対応した `Invoice` が同時に発行されていなければいけない
- 割引コードの使用済みフラグを、 `Order` と一緒に管理しなければいけない

### Integrity

型システムを活用すると「最低でもひとつの要素を持つリスト」や「メアドの認証・未認証管理」などのビジネスロジックも表現できる。
直和型でビジネスロジックの分岐を表現することで、開発者の行動を適切に制限することができる。
たとえば、最初にユーザーの入力から得られるのが `EmailAddress` 型ならば、 `VerifiedEmailAddress` 型が必要な関数は動かせない、など。

型を使うと、たとえば下記のように、テストなしで正しい値を担保できるね！
- `UnvalidatedOrder` のプロパティとして `UnvalidatedAddress` が定義されていて、 `ValidatedOrder` のプロパティには `ValidatedAddress` が定義されている
- `ValidatedOrder` にはprivate constructorが定義されている（モジュールの外部でインスタンス化できない）

### Consistency

一貫性はビジネス要件で技術要件ではない。にも関わらず大きな負担をシステム設計にかけるので、できれば避けたい...。
たとえば、商品の価格が変更されたら未請求の発注はすべて料金を変更すべきか？それとも未来の発注だけに適用すべきか？など。
要求の収集後、プロダクトオーナーが無茶な一貫性を要求してくることはよくあるが、それは大抵退けられるか、もしくは実装を遅らせられる。
Aggregateの境界を意識して、その内部で一貫性を保つ仕組みを考えるのが筋が良い。

Bounded contextをまたいで一貫性を担保する必要（あるタイミング以降、発注に紐づく請求情報が必要）があることはある。
だが、だからといってBounded contextの向こう側のオブジェクトを操作したり、彼らと同期を取ってはいけない。
ビジネス現場でそんな同期が必要になることは、まぁない。だって面倒だし。
Bounded contextをまたいだ一貫性は、非同期に、メッセージを利用して行うことが多い。なにかしらでミスることはたまにあるが、同期的に一貫性を担保するよりは、そういう稀なエラーに対処する方がまだ安くつくことが多い。そして、稀なエラーへの対処方針はいくつか考えられる。

- 何もしない。エラーが超レアで、かつ起こったときのコストが安いならそれでOK（例: コーヒーショップ）
- リコンサイル（照合）する。2つのデータを比べる別のプロセスを立てて、そいつに調査させ、不整合があれば再度メッセージを送信させる。
- 相殺イベントを送る。発注業務を例にすると、返金や返品処理を実装するのが、これに相当する。

2個目か3個目を使うと、結果整合性を担保することができる。

Bounded contextは同じだけど、Aggregateが別の場合でも、大抵はメッセージングを使うのが良い。
お金の振り込みのように、ビジネスプロセスが複数のAggregate（この例だと口座）を1つのトランザクションで変更することを強く求める場合はその限りではないが... その場合は、大抵その行為にIDが振られている。
ということは、DDDにおけるエンティティを発見したと考えることができる。お金の振り込みの例ならば「複数のAggregate（口座）の更新」ではなく「振り込み」というエンティティとして表現することができるはずだ。

## 感想・疑問
Measureを使って型安全を、というのはまだあんまピンと来ない。単なる装飾を超えて意味のある機能になるのか...？
「最低でもひとつの値を持つリスト」は、「FirstとRestを持つ直積型として定義できる」って考え方は、なんか静的型付け言語の面白いところな気がした。たしかにそれなら、いついかなる時でも要件を守れる。
ビジネスロジックを型に落とし込むのは、とてもおもしろいと思った。一方で、結局勝手に変換用の関数を書かれたりしないようにレビューする必要はあるから、魔法のメソッドというわけでもないな、とも感じた。

DDDのEntityの発見は、なんかもう答えがなさすぎて果てしないな、という気持ちになってきた。
振り込みを、複数口座の更新ではなく「振り込み」イベントと捉えて、トランザクションを1つにすべし、って言われて、たしかに！！！！！！！と思ったが、一方で自分の事業領域で同じレベルの閃きを生み続ける自信がちょっとない。

実際に自分でコードを書いてみようと思っても、一定以上に複雑なワークフローが存在しないと、そもそもモデル化することも難しそうだ。
あっ、そこでアーキテクチャ・カタとかが出てくるのか。
