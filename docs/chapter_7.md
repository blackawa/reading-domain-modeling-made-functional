## メモ

パイプラインを、データの変換を行う小さなパイプの集合とすることを「Transformation Oriented Programming（変換指向？プログラミング）」と呼ぶことがある。

パイプラインのインプットに関する、よくある課題
- インプットとして必ず欲しい情報（操作したユーザーのIDやタイムスタンプ）がある場合、Genericsを使うことで実現できる。
- 様々なコマンドがパイプラインに届く場合、直和型でパターンマッチを書くと良い。

### 発注を状態の集合と捉える

「発注」という直積型をひとつ定義するだけでもいいが、これをやるといろんな条件を全部吸い取ってしまう。状態ごとに異なるドメインモデルを設計することで、暗黙知やNullableなフィールドを除去できる。
直積型で作った状態を、直和型で集合にすることで、明示的なドメインモデルを設計できる。これで、要件の変更に対する柔軟性が非常に高くなる（たとえば RefundedOrderが必要になったら、直和型の選択肢がひとつ増えるだけ）。

### ステートマシンを作る

状態遷移を実装することで、
- ある状態ごとに許可された振る舞いを分離できる。
- すべての状態を明示できる。
- あり得る全ての遷移を想定できる。

などの利点を享受できる。

### ステップを型で設計する

ワークフローが内包する子ワークフローは、単に関数の依存関係として実装できる。
副作用がある場合は、その結果をResultとして型定義し、内部実装がキューイングが同期的なHTTP APIコールかは、後で決めればヨシ。

### 副作用を明文化する

リモートサービスの呼び出しはautonomy（単独で業務遂行な度合い）を阻害するが、だからといって自社で住所チェックサービスを作ろうとすれば大変なことになる。
リモートサービスに依存するなら、
- そいつが失敗する可能性も込みで型を設計する
- サービスが正しく振る舞うことを信用する（か、適宜応急処置を取る）

非同期処理が挟まるなら、ワークフロー全体がAsyncResultを返すようにすべき。

### 子ワークフローを組み合わせて、ワークフロー全体を構築する

子ワークフローのI/Oを型パズルする必要は、ぶっちゃけある。

### 依存関係ってドキュメント化するほど明示が必要？

依存関係はワークフローの内部に隠蔽してしまえばいいのでは？どれくらいの依存は隠蔽して良くて、どんな時は明示するべきか？
結論、
- Bounded contextの外部に公開されてるなら、依存関係は隠蔽しましょう
- context内の話なら、依存関係は明示しよう



## 感想・疑問

硬い型があると、一連のワークフローをパイプラインとして設計できて、型パズルを満たすようにコードを書いていけばシステムが完成する、って仕組みが作れて分業が捗りそう。
冗長でも、状態ごとに異なるドメインモデルを組んでおくと、変更に強くなるのはたしかに、って感じ。ただ、あらゆる場所のパターンマッチに条件が追加されると思うと、これもまた魔法ではないとも思う。結局、ビジネスロジックの変更がワークフロー全体に波及するなら、システムも同じように全体的な変更を余儀なくされる、ということだ。「現実の変更に対するシステムの変更量が1:1に近いほど良い」みたいなKPIが作れたりしそう。

イベント、ワークフロー、ドメイン、値、など、DDD用語の関連がわからなくなってきた...。